#summary Manual to Lsyncd Version 2.0
= Contents =
<wiki:toc max_depth="2" />

= Introduction =
This Manual aims to be a full documentation of Lsyncd version 2.0 capabilities and go into detail about it config scripts interface.

= What's new in 2.0? =
  * Lsyncd 2.x allows you to specify different actions for different kind of events. Particularly moves can now be implemented to be moved locally at the target instead of hitherto deletion of the origin and retransfer of the destination.

  * Multiple events on one file or directory are still collapsed as in Lsyncd 1.33+. But Lsyncd 2 tracks the kind of event and collapses events logically. E.g. A _Create_ and a _Modify_ will be collapsed in a _Create_; a _Modify_ and a _Delete_ into a _Delete_; etc.

  * Multiple targets now each have their own waiting list of events. A slow responding targets server no longer delays other targets.

  * Lsyncd can be configured to run multiple processes at once for one child. It will resolve any conflicts and only run processes in parallel for files and directories that don't interfere with each other.

  * Lsyncd 2.x does no longer halt and wait for a return of child processes it spawned. The kernels inotify queue will thus continously being drained making _Overflows_ less likely.

  * The format of the config file has changed completely. Instead of XML the configuration file has to be valid [http://www.lua.org/ Lua syntax]. 

  * Consequently Lsyncd 2 has no binding to libxml2 anymore, but instead liblua5.1

  * Users can create short scripts right within the config file.

  * Effort has been made while making the most common application of Lsyncd using rsync easy with default settings to keep lsyncd tidy as a general purpose file watching and action tool.

  * Retry on network error is now an integral part of Lsyncd.

  * Has improved exclude patterns.

  * The new setting "statusfile" will instruct Lsyncd to periodically write a report of its status in this file. E.g. amount of directories being watched, events in queue, actions in process etc.

  * A good part of the Lsyncd daemon itself is now coded in Lua. 

= Compiling Lsyncd =

Building Lsyncd is a straight forward standard process for unix packages. Unpack the downloaded tar.gz-file and run:
{{{
./configure
make
sudo make install
}}}

When you grabbed the source directly from subversion run {{{./autogen.sh}}} first.

With this standard configuration the parts of Lsyncd written in Lua (the runner) will be compiled into the binary. This results into a self-sufficient one-file binary. But Lsyncd can be configured to load the runner from an external file with the {{{--with-runner=DIRECTORY}}} option. This is especially useful in Lsyncd development.

= Invoking Lsyncd =

As any unix tool, Lsyncd will print a synopsis of its command line options when called with --help. 
{{{
lsyncd --help
lsyncd -help
}}}
By the way, the two hyphens are redundant for Lsyncd. It has no short one letter options and one hyphen will always result into the same as specifying two.

Also like any unix tools --version or -version will let it print its version number.
{{{
lsyncd -version
}}}

Lsyncd 2.0 is designed to be primarily configured through a config file (see below). The config file can thus be the only command line optin.
{{{
lsyncd CONFIGFILE
}}}

Altough for standard use or quick testing it can be cursorily facilely configured by commandline. This will keep a local src and dst directory in sync using rsync.
{{{
lsyncd -rsync /home/USER/src /home/USER/dst
}}}

The target can here be anything that rsync recognizes.
{{{
lsyncd -rsync /home/USER/src remotehost:dst
}}}

Two (and more) targets are configured by calling -rsync twice (or more).
{{{
lsyncd -rsync /home/USER/src remotehost1:dst -rsync /home/USER/src remotehost2:dst 
}}}

A disadvantage with rsync synchronization is that normally directory and file moves result in a deletion of the move origin and a retransfer of the move destination of the wire. A main improvement of Lsyncd 2.0 is, it now can use ssh commands to move the directories and files locally on the target. To use this use {{{-rsyncssh}}} followed by the local source directory, the remote host and the target directory there. The REMOTEHOST can include a user like {{{me@remotehost.com}}}.
{{{
lsyncd -rsyncssh /home/USER/src REMOTEHOST TARGETDIR
}}}

When testing Lsyncd configurations {{{-nodaemon}}} is a pretty handy flag. With this lsyncd will not detach and become a daemon. All log messages are additionally to the configured logging facilities printed on the console (_stdout_ and _stderr_). 
{{{
lsyncd -nodaemon CONFIGFILE
}}}
Note there is a difference in behaviour. When running with -nodaemon, Lsyncd will not change its working directory to {{{/}}}, as it does when becoming a daemon. Thus relative targets like {{{./target}}} will work with {{{-nodaemon}}}, but must be specified to absolute paths to work in daemon mode. The source directories will also be turned into absolute paths by Lsyncd. The reason targets are not resolved to absolute paths while sources are is because Lsyncd itself does not care about the format of the target specifier which can also be remote hosts, rsyncd modules, etc. It is opaquely handed to rsync. It cares about the observed directories tough.

By default Lsyncd is pretty scarce with logging message. All log messages are sorted in categories. You can turn Lsyncd into a motormouth by specifying {{{-log all}}}.
{{{
lsyncd -log all CONFIGFILE
}}}

This might easily become too much tough. A particularly useful category might be "Exec" which will log the command lines of all processes Lsyncd spawns
{{{
lsyncd -log Exec CONFIGFILE
}}}

Part of lsyncd is written in Lua. By default it is directly compiled into the binary, but can be configured at compiletime and runtime to be loaded from a file as well. To see where the a lsyncd binary will draw its runner from, just call it with {{-runner}}:
{{{
lsyncd -runner
}}}

You can override the default Lsyncd runner with adding a file:
{{{
lsyncd -runner RUNNERFILE
}}}

= The Configuration File =

Lsyncd configurations files are valid [http://www.lua.org/ Lua syntax]. It is designed to be simple yet potent. While rich configuration and simplicity are not opposites by themselves some trade-offs are inevitable. Do achieve both goals as far as possible, Lsyncd configuration can be done at different layers. Lower layers add adaptability while the interface becomes a bit more engaging.

== Settings ==

For scripts of all layers, with the global variable {{{settings}}} daemon-wide configurations can be specified. Every settings has to have a key and value. 

For example following code will instruct Lsyncd to log into {{{/tmp/lsyncd.log}}}, periodically update the file {{{/tmp/lsyncd.status}}} with its status and to not detach as a daemon.
{{{
settings = {
   logfile    = "/tmp/lsyncd.log",
   statusFile = "/tmp/lsyncd.status",
   nodaemon   = true,
}
}}}

Valid keys for settings are:
|| logfile         || = || FILENAME || logs into this file                         ||
|| nodaemon        || = || true     || does not detach                             ||
|| statusFile      || = || FILENAME || periodically writes a status report to file ||
|| statusIntervall || = || NUMBER   || writes the status file at shortest every Number seconds ||

Additionally some parameters can be configured, which are inherited by all _Syncs_ (see Layer 3)
|| maxDelays       || = || NUMBER || When this amount of delayed events is queued, actions will be spawned, even below the delay timer. ||
|| maxProcesses    || = || NUMBER || Lysncd does not spawn more than these number of processes per sync ||


== Layer 4 Configuration: Default Behaviour == 

You can simply choose from a set of default configurations. There are currently two default configs to choose from: __rsync__ and __rsyncssh__.

To sync a local directory using default rsync behaviour just add this to a config file:
{{{
sync{default.rsync, source="DIRNAME", target="DIRNAME"}
}}}
The order of the arguments is of no importance. If target is a local directory, take care it is an absolute pathname. You can add several syncs that way. The source dirs may be identical or one a subdirectory of another. {{{source}}} is an universal parameters that has must be given for every sync. All other {{{sync}}} parameters can differ depending on the behavior selected. Universally optional you can override the default or settings values {{{maxDelays}}} or {{{maxProcesses}}} per _Sync_. 

Following are default behaviors explained you can select from.

==== default.rsync ====
The default rsync configuration will aggregate events up to 20 seconds or 1000 seperate uncollapsible events, which ever happens first. Then it will spawn one rsync with a filter of all files that actually changed. The filter list is transfered trough a pipe. A call from Lsyncd to rsync will thus look like this:
{{{
/usr/bin/rsync -ltsd --delete --include-from=- --exclude=* SOURCE TARGET
}}}
You can change the "-lts" part by specifying other {{{rsyncOps}}}. 'd' or 'r' options are appended to {{{rsyncOps}}} by default.rsync as needed.

Example:
{{{
sync{source="/home/user/src/", target="foohost.com:~/trg/", rsyncOpts="-ltus"}
}}}

==== default.rsyncssh ====
This configuration differs from standard rsync in that it uses ssh commands to move files or directory locally at the target instead of transfering them over the wire. This configuration does spawn rsyncs like default.ssh but additionally will spawn {{{/usr/bin/ssh HOST mv ORIGIN DESTINATION}} commands. Per default it waits up to 10 seconds and will spawn up to 10 synchronous processes.

Different to default.rsync it does not take an uniform {{{target}}} parameter, but needs {{{host}}} and {{{targetdir}}} separated. Again rsync short options can be changed with {{{rsyncOpts}}}

Example:
{{{
sync{source="/home/user/src/", host="foohost.com", targetdir="~/trg/" rsyncOpts="-ltus"}
}}}

=== Exclusions ===
Two additional parameters can be specified two sync{}
|| excludeFrom     || = || FILENAME || loads exclusion rules from this file, on rule per line        ||
|| exclude         || = || LIST     || loads exclusion rules from this list of strings      ||

Exclusion rules are modeled after rsyncs exclussion patterns. Just a bit simpler. Lsyncd supports this features.

 * Generally if any part of the pathname (see below Layer 3) of an event matches the text, it is excluded. E.g. the file "/bin/foo/bar" matches the rule "foo".
 * If the rule starts with a slash, it will only be matched at the beginning of the pathname
 * If the rule ends with a slash, it will only be matched at the end of a pathname
 * ? matches any character that is not a slash.
 * {{{*}}} matches zero or more characters that are not a slash
 * {{{**}}} matches zero or more characters, this can be slashes.

== Layer 3 Configuration: Simple onAction Commands == 

In this layer custom configuration can created. This example will use bash commands to keep a local directory in Sync.

{{{
bash = {
    delay = 5,

    maxProcesses = 3,

    onCreate = "cp -r ^sourcePathname ^targetPathname",

    onModify = "cp -r ^sourcePathname ^targetPathname",

    onDelete = "rm -rf ^targetPathname",

    onMove   = "mv ^o.targetPathname ^d.targetPathname",

    onStartup = [[if [ "$(ls -A ^source)" ]; then cp -r ^source* ^target; fi]],
}
}}}

The example explained step by step. Technically any Lsyncd configuration a lua table with a set of keys filled out. Thus it starts by creating a variable called {{{bash}}} and assigns it a table with = { ... }.

{{{
bash = {
  ...
}
}}}

Now the table is filled with entries. Every entry having a key left of the equal sign and its value right of it. If no delay is specified this means immediate actions for Lsyncd. This example wants to aggregate changes for 5 seconds thus the next entry is:
{{{
    delay = 5,
}}}
And a comma is needed since to mark the end of an entry.

Actions are specified by the 6 keys: 

|| {{{onAttrib}}}  || called when only attributes changed              ||
|| {{{onCreate}}}  || called on a new file or directory                ||
|| {{{onModify}}}  || called when a file has changed                   ||
|| {{{onDelete}}}  || called when a file or directory has been deleted ||
|| {{{onMove}}}    || called when a file or directory has been moved within the observed directory tree ||
|| {{{onStartup}}} || called on the start of Lsyncd.                   ||

When there is no {{{onMove}}} or the move goes into or out of the observed directory tree, it is split into a {{{onDelete}}} of the move origin and a {{{onCreate}}} of the move destination. That is if either is within the observer directory tree.

{{{onStartup}}} will always block all other actions for this _Sync_ until completed, regardless how big {{{maxProcesses}}} is.

The action to be taken is specified as a Lua String. Thus they can be delimited with anything Lua allows, thes are 'TEXT', "TEXT", or [[TEXT]] as used in {{onStartup}} in the example above. 

Any action starting with a "/" result in the binary starting at the beginning directly being called by Lsyncd. For example
{{{
   onCreate = "/usr/bin/zip /usr/var/all.zip ^sourceName"
   onModify = "/usr/bin/zip /usr/var/all.zip ^sourceName"
}}}
will add any newly created and modified files to /usr/var/all.zip using absolute path names. Any action not starting with a "/" will result in Lsyncd spawning a shell to execute the action as command. For example see above.

Variable arguments are specified with the caret symbol ^. It has been chosen over $ or other symbols to be less conflicting with standard shell conventions. 

All possible variables:

|| ^source || The absolute path of the observed source directory. ||
|| ^target || The "target" attribute of the config.               ||
|| ^path || The relative path of the file or directory to the observed directory. Directories have a slash at the end. ||
|| ^pathname || The relative path of the file or directory to the observed directory. Directories have no slash at the end. ||
|| ^sourcePath || The absolute path of the observed source directory and the relative path of the file or directory. This equals the absolute local path of the file or directory. Directories have a slash at the end. ||
|| ^sourcePathname || Same as ^sourcePath but directories have no slash at the end. ||
|| ^targetPath || The "target" arrbiuted of the config appended by the relative path of the file or directory. Directories have a slash at the end. ||
|| ^targetPathname || Same as ^targetPath but directories have no slash at the end. ||

For {{{onMoves}}} a _o._ and or _d._ can be preppended to path, pathname, sourcePath sourcePathname, targetPath and targetPathname to specify the move origin or destination. Without neither the variables refers to the move origin. 

From the example above, it moves the file or directory in the target directory.
{{{
    onMove   = "mv ^o.targetPathname ^d.targetPathname",
}}}

A few word on the startup of the example. It looks a little more complicated, but it is just some bash scripting, nothing Lsyncd specifc. It simply does a recursive copy of the source to the target, but first tests if there is anything in the sourcefile. Otherwise the command returns a non-zero error code.

{{{
    onStartup = [[if [ "$(ls -A ^source)" ]; then cp -r ^source* ^target; fi]],
}}}

By default Lsyncd ignores all exitcodes except onStartup which must result a 0 for it to continue. You can change this behavior by adding a {{{exitcodes}}} table.

{{{
    exitcodes = {[1] = "again", [2] = "die"}
}}}
The keys specify the exitcode the string the action. 
|| "again" || respawns the action after {{delay}} seconds, or 1 second if delay is immediate ||
|| "die"  || lets Lsyncd terminate. ||
All other values let Lsyncd continue normally.

== Layer 2 Configuration: Advanced onAction Commands == 

While Layer 4 and 3 feel like normal configuration files, Layer 2 and 1 enter the realm of coding. It is thus supposed you have some coding knowledge when using Layer 2 or 1.

Instead of designating actions as strings as in Layer 3 Lua functions can used to do some small scripts right within Lsyncd.

This example will convert any convert any file with the suffix ".ps" created in a directory into a pdf.

{{{
autopdf = {
    onCreate = function(event)
        log("Normal", "got an onCreate Event")
        if string.ends(event.pathname, ".ps") then
            spawn(event, "/usr/bin/ps2pdf", event.sourcePath)
        end
    end,
}}}

The function can take any valid Lua code. 

Lsyncd provides you a set of functions to be used in user scripts.

==== log(Category, ...) ====
Logs a message into file/stdout/syslog. The first parameter is the logging category all others are strings to be logged. A logging category must start with a capital letter. "Normal" and "Error" are standard categories for log messages. All others are categories for debugging.

==== spawn(Event, Binary, ...) ====
Spawns a new process associated with the event (or event list, see below) as first parameter. The second parameter specifies to binary to call. All others are arguments for the binary. 

If the third parameter is "<" it and the forth will not be passed as argument to the binary. The forth parameter is a string that will piped through stdin to the binary.

Do not use Luas {{{os.execute}}} as differently to Lsyncds {{{spawn()}}} it will block an thus block the whole Lsyncd daemon until the command is completed. Lsyncds {{{spawn}}} on the other hand returns immediately while the child process runs.

===== spawnShell(Event, Command, ... ) =====
The same as spawn(), only it will invoke a shell. Any parameters are referred as $1, $2, $3 and so on in the command. 

By the way, this is the simple implementation of spawnShell:
{{{
function spawnShell(agent, command, ...)
    return spawn(agent, "/bin/sh", "-c", command, "/bin/sh", ...)
end
}}}

===== terminate(exitcode) =====
Lets Lsyncd terminate with {{{{exitcode}}}}.

==== event =====
Variables of the actions are given by the _event_ field. It has following fields.

|| event.config         || the configuration as called with sync{}.  ||
|| event.inlet          || see layer 1 about inlets                  ||
|| event.etype          || the event type. Can be 'ATTRIB', 'CREATE', 'MODIFY', 'DELETE', 'MOVE' ||
|| event.status         || the status of the event. 'wait' when it is ready to be spawned and 'active' if there is a process running associated with this event ||
|| event.isdir          || true if the event relates to a directory ||
|| event.name           || the filename. directories end with a slash ||
|| event.basename       || the filename. directories do not end with a slash ||
|| event.path           || see ^path of layer 2 ||
|| event.pathname       || see ^pathname of layer 2 ||
|| event.source         || see ^source of layer 2 ||
|| event.sourcePath     || see ^sourcePath of layer 2 ||
|| event.sourcePathname || see ^sourcePathname of layer 2 ||
|| event.target         || see ^target of layer 2 ||
|| event.targetPath     || see ^targetPath of layer 2 ||
|| event.targetPathname || see ^targetPathname of layer 2 ||

onMove actions have two events as parameter, the origin and the destination of the move.

This example will tattle about all moves within the observed dirotery tree.
{{{
tattleMove = {
    onMove = function(oEvent, dEvent)
        log("Normal", "A moved happened from ",oEvent.pathname," to ",dEvent.pathname)
    end,
}}}

A general tip about writing action function is to keep them short and fast. They are running right within Lsyncds one and only main thread. If you have to do any more time consuming calculations _spawn{}_ a child process instead. 

There can only be one child process associated to a event.

Layer 3 is nothing else than Lsyncd automatically write Layer 2 functions for you on initialization. Start lsyncd with {{{-log FWrite}}} on a Layer 3 configuration to see what functions it dynamically writes and loads for you. Thus Layer 3 and 2 can also be be mixed at will.

== Layer 1 Configuration: Inlets == 

Layer 2 allows you to create one process per one event. However, as with default rsync behavior you might want to call one process for several events. This can be done with inlets. When any event becomes ready Lsyncd calls the {{{action}}} entry with {{{inlet}}} as parameter. The {{{inlet}}} can be used to grap ready single events or event lists.

For example this is the action used by default.rsync:
{{{
action = function(inlet)
   local elist = inlet.getEvents()
   local config = inlet.getConfig()
   local paths = elist.getPaths()
   log("Normal", "rsyncing list\n", paths)
   spawn(elist, "/usr/bin/rsync",
       "<", paths,
       "--delete",
       config.rsyncOps .. "d",
       "--include-from=-",
       "--exclude=*",
       config.source, config.target)
}}}

Inlet functions are:
|| inlet.getEvent()  || Retrieves the next {{{event}}} as in Layer 2 configuration. Multiple calls to getEvent() will return the same event unless it has spawn{}ed an action. ||
|| inlet.getEvents(test) || Returns a list of all events that are ready. {{{test}}} is optional for a function that will be called for every event to test if it should be included in the list. It has one parameter the {{{event}}} and returns true if an event should be included. If nil every ready event will be included in the list ||
|| inlet.discardEvent() || Discards an event. The next call to getEvent will thus receive another event, even if no action has been spawned for this event ||
|| inlet.getConfig()    || returns the same as {{{event.config}}}. The configuration of the sync{} ||
|| inlet.addExclude()   || adds an exclusion pattern to this sync (see Exclusions) ||
|| inlet.rmExclude()    || removes an exclusion pattern from this sync ||
|| inlet.createBlanketEvent() || puts an {{{event}}} on the top of the Delay FIFO that blocks all events and is blocked by all events. This is used for onStartup.  ||

The list returned by getEvents can be handed to spawn{} as _agent_ just as well as singular events.

Lists have following functions 
|| elist.getPaths(delimiter)       || returns a string of the paths (as in {{{event.path}}} separated by {{{delimiter}}}. By default \n is user as delimiter. ||
|| elist.getSourcePaths(delimiter) || returns a string of the sourcePaths (as in {{{event.sourcePath}}} separated by {{{delimiter}}}. By default \n is user as delimiter. ||

Take care calling getEvents() and its function since depending on the amount of events, they will cause quite some CPU load.

Layer 2 functions is nothing else than following layer 1 action loaded by the default if the user script did not provide one itself.

{{{
-----
-- Default action calls user scripts on**** functions.
--
action = function(inlet)
    -- in case of moves getEvent returns the origin and dest of the move
    local event, event2 = inlet.getEvent()
    local config = inlet.getConfig()
    local func = config["on".. event.etype]
    if func then
        func(event, event2)
    end 
    -- if function didnt change the wait status its not interested
    -- in this event -> drop it.
    if event.status == "wait" then
        inlet.discardEvent(event)
    end 
end,
}}}

Lsyncd will automatically split Move events into Create and Delete events if no "onMove" field is found in the config. When handling moves in layer 1 {{{action}}} function, simply set "onMove" to be "true". 

Other than {{{action}}} Lsyncd calls {{{init}}} for each sync{} on initialization. This is the default init function which is loaded if the user script does not have one. It provides the onStartup() functionality for layer 2 and 3.

{{{
-----
-- called on (re)initalizing of lsyncd.
--
init = function(inlet)
    local config = inlet.getConfig()
    -- calls a startup if provided by user script.
    if type(config.onStartup) == "function" then
        local event = inlet.createBlanketEvent()
        config.onStartup(event)
        if event.status == "wait" then
            -- user script did not spawn anything
            -- thus the blanket event is deleted again.
            inlet.discardEvent(event)
        end 
    end 
end,
}}}

As another example this is the init of {{{default.rsync}}}. As specialty it changes the configuration in that it adds a slash to target if not there already.

{{{
-----
-- Spawns the recursive startup sync
-- 
init = function(inlet)
    local config = inlet.getConfig()
    local event = inlet.createBlanketEvent()
    if string.sub(config.target, -1) ~= "/" then
        config.target = config.target .. "/" 
    end 
    log("Normal", "recursive startup rsync: ", config.source,
        " -> ", config.target)
    spawn(event, "/usr/bin/rsync", 
        "--delete",
        config.rsyncOps .. "r", 
        config.source, 
        config.target)
end,
}}}

When child processes are finished and their zombie processes are collected, Lsyncd calls the function of the {{{collect}}} entry. When collect return "again" the status of the agent (an event or an event list) will be set on "wait" again, and will become ready in {{{delay}}} seconds (or 1 second if smaller).

The default collect function looks in the exitcodes[] table for an entry of the exitcode. Otherwise most of the unfortunately longer code below does nothing but making nice log message.

{{{
-----
-- Called when collecting a finished child process
--
collect = function(agent, exitcode)
	local config = agent.config

	if not agent.isList and agent.etype == "Blanket" then
		if exitcode == 0 then
			log("Normal", "Startup of '",agent.source,"' finished.")
		elseif config.exitcodes and 
		       config.exitcodes[exitcode] == "again" 
		then
			log("Normal", 
				"Retrying startup of '",agent.source,"'.")
			return "again"
		else
			log("Error", "Failure on startup of '",agent.source,"'.")
			terminate(-1) -- ERRNO
		end
		return
	end

	local rc = config.exitcodes and config.exitcodes[exitcode] 
	if rc == "die" then
		return rc
	end

	if agent.isList then
		if rc == "again" then
			log("Normal", "Retrying a list on exitcode = ",exitcode)
		else
			log("Normal", "Finished a list = ",exitcode)
		end
	else
		if rc == "again" then
			log("Normal", "Retrying ",agent.etype,
				" on ",agent.sourcePath," = ",exitcode)
		else
			log("Normal", "Finished ",agent.etype,
				" on ",agent.sourcePath," = ",exitcode)
		end
	end
	return rc
end,
}}}

= Examples =
== Layer 4 Examples ==

== Layer 3 Examples ==
 * [ExampleGForce Forces a local directorytree to be read/writeable by a group.] 

== Layer 2 Examples ==

== Layer 1 Examples ==
 * [ExampleAutoImageMagic Creates a "magic" directory in which all images placed into will be converted to other file formats]

= Developer Manual =

When developing it is wise to configure Lsyncd to load the runner from your development directory. So you do not have to rerun make every time you change {{{lsyncd.lua}}}.
{{{
./configure --with-runner=/home/USER/lsyncd2/
}}}

== Roadmap ==

Lsycnd 2.0 release 
 * man pages 
 * an automatic testsuite like lsyncd 1.x has (some unit tests)
 * user feedback on beta releases

While work could go on, there is a moment to call things pause and postpone some work to later.

Lsyncd 2.1+: (any future versions)
 * Optimization of the _Delay_ construct. Lsyncd goes a few times linearly through its delay Fifo where it would not have to. Code it as Queue and use pathnames as hashtables to quickly find blocks.
 * fanotify support - brand new in linux 2.6.36, supercedes inotify and using this saves a lot of kernel memory if watching big source dirs.
 * fsevents support - similar to i/fanotify, but on OS X 
 * support for includes, currently only masks for excludes are supported.
 * Supposedly tons of bug fixes to Lsyncd 2.0(betaX)

== Code structure / Style guide ==
At large Lsyncds in source code comment documentation is well developed - at least compared to many other software projects. Here thus only a few outlining words.

Lsyncd 2 is partially written in C, partially written in Lua. For some code pieces it is a free decision in which it could be coded, but for most one of the two was more appropriate. Generally the goal was if there was no good reason to code something in C do it in Lua. The C core thus does all the stuff close to the operating system:
 * inotify interface
 * process management, zombie collection
 * signals
 * pipes 
 * logging (also in the core, so it can log itself comfortably)
 * alarms (lsyncd uses kernel jiffies as alarms, thus it should be year Y2K38 safe (the year in which an often used time measurement - seconds since 1970 will overflow)
Everything else is done in lsyncd.lua.

While Lua is not an object oriented language itself, it supplies a set of features which can emulate its features quite nicely. Shortly spoken, it supports prototyping. Lsyncd makes use of local function scoping to create blocks of code which are loosely connected with each other. A major feature of object oriented language.

A typical "class" in Lsyncd looks like this.
{{{
MyClass = (function()
    local private = "only visible here"
    local function new() 
        return {foo="bar"}
    end
    -- public interface
    return { new = new }
end)()
}}}
In plain interpretation this creates a global variable called "MyClass". It defines an unnamed function with internal variables and subfunctions. This functions returns a table of all functions that should be visible from the outside. Then the unnamed function is called immediately called on the global definition of "MyClass" and the public interface table stored in "MyClass". {{{MyClass.new()}}} is then used to create objects of this class. Or if it is a "Singelton", it has no new function, but other functions, that would be considered "static" in an object oriented language.

Lua has developed a culture for personal adaption - "power patches". To not throw a stick into any package maintainer Lsyncd uses standard from the stock Lua (5.1).

One note about the style of sync{} configs. As you can see in Layer 4 configuration the configuration is selected by merely adding the configuration table as parameter. In the implementation it does nothing else than to take any value with a number as key and which has a table as value and copy all of its key/value entries that are not there already. This even works recursively if that config again imports another config. 

== Why Lua and not ...? =
Lua has been chosen for Lsyncd 2 much out of the same reasons why C was chosen for Lsyncd 1.x. Lsyncd should be small and fast and should come with as few as possible dependencies. 

The move from a pure C implementation as in Lsyncd 1.x to using Lua was motivated by enhancing the configuration file format. XML was starting to get clunky for the requirements of Lsyncd. When used Lua bindings already for config file parsing, there was little reason not to move large parts of Lsyncd internal logic into Lua as well. With its garbage collector memory management became much easier, and with its highly optimized tables as dictionaries some things even become faster, as Lsyncd 1.x linearly traversed a lot of lists, while Lsyncd 2 uses Lua tables as hash tables everywhere. 

Lua was chosen over other script languages not because I think Lua is the greatest thing on earth - like many coders think about their favorite language. But because it is considered to be a appropriate tool for this task. Many coders like [X] so much, they want to do everything with it, also because after a while they know [X] very well, and are of course faster in solving an issue than learning [Y]. I on the other hand didn't know Lua before Lsyncd 2 at all, and decided explicitly for it out of pragmatic reasons. First it is said have originated out of the need for configuration files for C applications. Much the use case Lsyncd needs. So the C interface is handy and fast. Since Lsyncd has its parts close to the system still coded in C this interfacing makes things easier. Lua is very fast. Without affronting other script languages one can say it is at least in the top tier regarding speed. It may the fastest scripts there is, but this statement might raise debates. But not without reason it got quite some attention from the gaming industry. It gets even faster with LuaJIT and is gets into the range of JavaJIT (which is a compiled and not a script language). Lua has also a very slim standard library, while this is a stopper for people just wanting to quickly write some script this plays into the hands of Lsyncd. It comes with little requirements on the machine to be installed and Lsyncd comes with its own custom core functionally anyway. And altough the LUA syntax looks a bit dirty at first - like implicit on the fly creation of globals - with a little configuration this can be banned. Like Lsyncd does in normal operation modes. 