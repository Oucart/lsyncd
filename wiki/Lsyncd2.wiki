#summary Manual to Lsyncd Version 2.x.
= Contents =
<wiki:toc max_depth="2" />

= Introduction =
Lsyncd version 2.0 is currently at beta1 as a complete recode of Lsyncd 1.x. *This manual is as well in development*.

= What's new in 2.0? =
  * Lsyncd 2.x allows you to specify different actions for different kind of events. Particularly moves can now be implemented to be moved locally at the target instead of hitherto deletion of the origin and retransfer of the destination.

  * Multiple events on one file or directory are still collapsed as in Lsyncd 1.33+. But Lsyncd 2 tracks the kind of event and collapses events logically. E.g. A _Create_ and a _Modify_ will be collapsed in a _Create_; a _Modify_ and a _Delete_ into a _Delete_; a _Create_ and a _Delete_ within the wait time (as it often happens with temporary files) will annihilate each other and result in Lsyncd not bothering the target at all.

  * Multiple targets now each have their own waiting list of events. A slow responding targets server no longer delays other targets.

  * Lsyncd can be configured to run multiple processes at once for one child. It will resolve any conflicts and only run processes in parallel for files and directories that don't interfere with each other.

  * Lsyncd 2.x does no longer halt and wait for a return of child processes it spawned. The kernels inotify queue will thus continously being drained making _Overflows_ less likely.

  * The format of the config file has changed completely. Instead of XML the configuration file has to be valid [http://www.lua.org/ Lua syntax]. 

  * Consequently Lsyncd 2 has no binding to libxml2 anymore, but instead liblua5.1

  * Users can create short scripts right within the config file.

  * Effort has been made while making the most common application of Lsyncd using rsync easy with default settings to keep lsyncd tidy as a general purpose file watching and action tool.

  * Retry on network error is now an integral part of Lsyncd.

  * Has exclude patterns that work.

  * The new setting "statusfile" will instruct Lsyncd to periodically write a report of its status in this file. E.g. amount of directories being watched, events in queue, actions in process etc.

  * A good part of the Lsyncd daemon itself is now coded in Lua. 

= Compiling Lsyncd =

Building Lsyncd is a straight forward standard process for unix packages. Unpack the downloaded tar.gz-file and run:
{{{
./configure
make
sudo make install
}}}

When you grabbed the source directly from subversion run {{{./autogen.sh}}} first.

With this standard configuration the parts of Lsyncd written in Lua (the runner) will be compiled into the binary. This results into a self-sufficient one-file binary. But Lsyncd can be configured to load the runner from an external file with the {{{--with-runner=DIRECTORY}}} option. This is especially useful in Lsyncd development.

= Invoking Lsyncd =

As any unix tool, Lsyncd will print a synopsis of its command line options when called with --help. 
{{{
lsyncd --help
lsyncd -help
}}}
By the way, the two hyphens are redundant for Lsyncd. It has no short one letter options and one hyphen will always result into the same as specifying two.

Also like any unix tools --version or -version will let it print its version number.
{{{
lsyncd -version
}}}

Lsyncd 2.0 is designed to be primarily configured through a config file (see below). The config file can thus be the only command line optin.
{{{
lsyncd CONFIGFILE
}}}

Altough for standard use or quick testing it can be cursorily facilely configured by commandline. This will keep a local src and dst directory in sync using rsync.
{{{
lsyncd -rsync /home/USER/src /home/USER/dst
}}}

The target can here be anything that rsync recognizes.
{{{
lsyncd -rsync /home/USER/src remotehost:dst
}}}

Two (and more) targets are configured by calling -rsync twice (or more).
{{{
lsyncd -rsync /home/USER/src remotehost1:dst -rsync /home/USER/src remotehost2:dst 
}}}

A disadvantage with rsync synchronization is that normally directory and file moves result in a deletion of the move origin and a retransfer of the move destination of the wire. A main improvement of Lsyncd 2.0 is, it now can use ssh commands to move the directories and files locally on the target. To use this use {{{-rsyncssh}}} followed by the local source directory, the remote host and the target directory there. The REMOTEHOST can include a user like {{{me@remotehost.com}}}.
{{{
lsyncd -rsyncssh /home/USER/src REMOTEHOST TARGETDIR
}}}

When testing Lsyncd configurations {{{-nodaemon}}} is a pretty handy flag. With this lsyncd will not detach and become a daemon. All log messages are additionally to the configured logging facilities printed on the console (_stdout_ and _stderr_). 
{{{
lsyncd -nodaemon CONFIGFILE
}}}
Note there is a difference in behaviour. When running with -nodaemon, Lsyncd will not change its working directory to {{{/}}}, as it does when becoming a daemon. Thus relative targets like {{{./target}}} will work with {{{-nodaemon}}}, but must be specified to absolute paths to work in daemon mode. The source directories will also be turned into absolute paths by Lsyncd. The reason targets are not resolved to absolute paths while sources are is because Lsyncd itself does not care about the format of the target specifier which can also be remote hosts, rsyncd modules, etc. It is opaquely handed to rsync. It cares about the observed directories tough.

By default Lsyncd is pretty scarce with logging message. All log messages are sorted in categories. You can turn Lsyncd into a motormouth by specifying {{{-log all}}}.
{{{
lsyncd -log all CONFIGFILE
}}}

This might easily become too much tough. A particularly useful category might be "Exec" which will log the command lines of all processes Lsyncd spawns
{{{
lsyncd -log Exec CONFIGFILE
}}}

Part of lsyncd is written in Lua. By default it is directly compiled into the binary, but can be configured at compiletime and runtime to be loaded from a file as well. To see where the a lsyncd binary will draw its runner from, just call it with {{-runner}}:
{{{
lsyncd -runner
}}}

You can override the default Lsyncd runner with adding a file:
{{{
lsyncd -runner RUNNERFILE
}}}

= The Configuration File =

Lsyncd configurations files are valid [http://www.lua.org/ Lua syntax]. It is designed to be simple yet potent. While rich configuration and simplicity are not opposites by themselves some trade-offs are inevitable. Do achieve both goals as far as possible, Lsyncd configuration can be done at different layers. Lower layers add adaptability while the interface becomes a bit more engaging.

== Settings ==

For scripts of all layers, with the global variable {{{settings}}} daemon wide configurations can be specified. Every settings has to have a key and value. 

For example following code will tell Lsyncd to log into {{{/tmp/lsyncd.log}}}, periodically update the file {{{/tmp/lsyncd.status}}} with its status and to not detach as daemon.
{{{
settings = 
   logfile    = "/tmp/lsyncd.log",
   statusFile = "/tmp/lsyncd.status",
   nodaemon   = true,
}}}


Valid keys for settings are:
|| logfile         || = || FILENAME || logs into this file                         ||
|| nodaemon        || = || true     || does not detach                             ||
|| statusFile      || = || FILENAME || periodically writes a status report to file ||
|| statusIntervall || = || NUMBER   || writes the status file at shortest every Number seconds ||

Additionally some parameters can be configured, which are inherited by all _Syncs_ (see Layer 3)
|| maxDelays       || = || NUMBER || When this number of delayed events is queued. Action will be taken ||
|| maxProcesses    || = || NUMBER || Lysncd does not spawn more than these number of processes per sync ||

== Layer 4 Configuration: Default Behaviour == 

You can simply choose from a set of default configurations. There are currently two configs to choose from: __rsync__ and __rsyncssh__.

To sync a local directory using default rsync behaviour just add this to a config file:
{{{
sync{default.rsync, source="DIRNAME", target="DIRNAME"}
}}}
The order of the arguments is of no importance. If target is a local directory, take care it is an absolute pathname. You can add several syncs that way. The source dirs may be identical or one a subdirectory of another. {{{source}}} is an universal parameters that has must be given for every sync. All other {{{sync}}} parameters can differ depending on the behavior selected. Universally optional you can override the default or settings values {{{maxDelays}}} or {{{maxProcesses}}} per _Sync_. 

Following are default behaviors explained you can select from.

==== default.rsync ====
The default rsync configuration will aggregate events up to 20 seconds or 1000 seperate uncollapsible events, which ever happens first. Then it will spawn one rsync with a filter of all files that actually changed. The filter list is transfered trough a pipe. A call from Lsyncd to rsync will thus look like this:
{{{
/usr/bin/rsync -ltsd --delete --include-from=- --exclude=* SOURCE TARGET
}}}
You can change the "-lts" part by specifying other {{{rsyncOps}}}. 'd' or 'r' options are appended to {{{rsyncOps}}} by default.rsync as needed.

Example:
{{{
sync{source="/home/user/src/", target="foohost.com:~/trg/", rsyncOpts="-ltus"}
}}}

==== default.rsyncssh ====
This configuration differs from standard rsync in that it uses ssh commands to move files or directory locally at the target instead of transfering them over the wire. This configuration does spawn rsyncs like default.ssh but additionally will spawn {{{/usr/bin/ssh HOST mv ORIGIN DESTINATION}} commands. Per default it waits up to 10 seconds and will spawn up to 10 synchronous processes.

Different to default.rsync it does not take an uniform {{{target}}} parameter, but needs {{{host}}} and {{{targetdir}}} separated. Again rsync short options can be changed with {{{rsyncOpts}}}

Example:
{{{
sync{source="/home/user/src/", host="foohost.com", targetdir="~/trg/" rsyncOpts="-ltus"}
}}}

== Layer 3 Configuration: Simple onAction Commands == 

In this layer custom configuration can created. This example will use bash commands to keep a local directory in Sync.

{{{
bash = {
    delay = 5,

    maxProcesses = 3,

    onCreate = "cp -r ^sourcePathname ^targetPathname",

    onModify = "cp -r ^sourcePathname ^targetPathname",

    onDelete = "rm -rf ^targetPathname",

    onMove   = "mv ^o.targetPathname ^d.targetPathname",

    onStartup = [[if [ "$(ls -A ^source)" ]; then cp -r ^source* ^target; fi]],
}
}}}

The example explained step by step. Technically any Lsyncd configuration a lua table with a set of keys filled out. Thus it starts by creating a variable called {{{bash}}} and assigns it a table with = { ... }.

{{{
bash = {
  ...
}
}}}

Now the table is filled with entries. Every entry having a key left of the equal sign and its value right of it. If no delay is specified this means immediate actions for Lsyncd. This example wants to aggregate changes for 5 seconds thus the next entry is:
{{{
    delay = 5,
}}}
And a comma is needed since to mark the end of an entry.

Actions are specified by the 6 keys: 

|| {{{onAttrib}}}  || called when only attributes changed              ||
|| {{{onCreate}}}  || called on a new file or directory                ||
|| {{{onModify}}}  || called when a file has changed                   ||
|| {{{onDelete}}}  || called when a file or directory has been deleted ||
|| {{{onMove}}}    || called when a file or directory has been moved within the observed directory tree ||
|| {{{onStartup}}} || called on the start of Lsyncd.                   ||

When there is no {{{onMove}}} or the move goes into or out of the observed directory tree, it is split into a {{{onDelete}}} of the move origin and a {{{onCreate}}} of the move destination. That is if either is within the observer directory tree.

{{{onStartup}}} will always block all other actions for this _Sync_ until completed, regardless how big {{{maxProcesses}}} is.

The action to be taken is specified as a Lua String. Thus they can be delimited with anything Lua allows, thes are 'TEXT', "TEXT", or [[TEXT]] as used in {{onStartup}} in the example above. 

Any action starting with a "/" result in the binary starting at the beginning directly being called by Lsyncd. For example
{{{
   onCreate = "/usr/bin/zip /usr/var/all.zip ^sourceName"
   onModify = "/usr/bin/zip /usr/var/all.zip ^sourceName"
}}}
will add any newly created and modified files to /usr/var/all.zip using absolute path names. Any action not starting with a "/" will result in Lsyncd spawning a shell to execute the action as command. For example see above.

Variable arguments are spe

        { "%^pathname"cified with the caret symbol. It has been chosen over $ or other symbols to be less conflicting with standard shell conventions. 

All possible variables

|| ^source || The absolute path of the observed source directory. ||
|| ^target || The "target" attribute of the config.               ||
|| ^path || The relative path of the file or directory to the observed directory. Directories have a slash at the end. ||
|| ^pathname || The relative path of the file or directory to the observed directory. Directories have no slash at the end. ||
|| ^sourcePath || The absolute path of the observed source directory and the relative path of the file or directory. This equals the absolute local path of the file or directory. Directories have a slash at the end. ||
|| ^sourcePathname || Same as ^sourcePath but directories have no slash at the end. ||
|| ^targetPath || The "target" arrbiuted of the config appended by the relative path of the file or directory. Directories have a slash at the end. ||
|| ^targetPathname || Same as ^targetPath but directories have no slash at the end. ||

For {{{onMoves}}} a _o._ and or _d._ can be preppended to path, pathname, sourcePath sourcePathname, targetPath and targetPathname to specify the move origin or destination. Without neither the variables refers to the move origin. 

From the example above, it moves the file or directory in the target directory.
{{{
    onMove   = "mv ^o.targetPathname ^d.targetPathname",
}}}

A few word on the startup of the example. It looks a little more complicated, but it is just some bash scripting, nothing Lsyncd specifc. It simply does a recursive copy of the source to the target, but first tests if there is anything in the sourcefile. Otherwise the command returns a non-zero error code.

{{{
    onStartup = [[if [ "$(ls -A ^source)" ]; then cp -r ^source* ^target; fi]],
}}}

By default Lsyncd ignores all exitcodes except onStartup which must result a 0 for it to continue. You can change this behavior by adding a {{{exitcodes}}} table.

{{{
    exitcodes = {[1] = "again", [2] = "die"}
}}}
The keys specify the exitcode the string the action. 
|| "again" || respawns the action after {{delay}} seconds, or 1 second if delay is immediate ||
|| "die"  || lets Lsyncd terminate. ||
All other values let Lsyncd continue normally.

== Layer 2 Configuration: Advanced onAction Commands == 

Instead of designating actions as strings as in Layer 3 Lua functions can used to do some small scripts right within Lsyncd.

This example will convert any convert any file with the suffix ".ps" created in a directory into a pdf.

{{{
autopdf = {
    onCreate = function(event)
        log("Normal", "got an onCreate Event")
        if string.ends(event.pathname, ".ps") then
            spawn(event, "/usr/bin/ps2pdf", event.sourcePath)
        end
    end,
}}}

The function can take any valid Lua code. 

Lsyncd provides you a set of functions to be used in user scripts.

==== log(Category, ...) ====
Logs a message into file/stdout/syslog. The first parameter is the logging category all others are strings to be logged. A logging category must start with a capital letter. "Normal" and "Error" are standard categories for log messages. All others are categories for debugging.

==== spawn(Event, Binary, ...) ====
Spawns a new process associated with the event (or event list, see below) as first parameter. The second parameter specifies to binary to call. All others are arguments for the binary. 

If the third parameter is "<" it and the forth will not be passed as argument to the binary. The forth parameter is a string that will piped through stdin to the binary.

Do not use Luas {{{os.execute}}} as differently to Lsyncds {{{spawn()}}} it will block an thus block the whole Lsyncd daemon until the command is completed. Lsyncds {{{spawn}}} on the other hand returns immediately while the child process runs.

===== spawnShell(Event, Command, ... ) =====
The same as spawn(), only it will invoke a shell. Any parameters are referred as $1, $2, $3 and so on in the command. 

By the way, this is the simple implementation of spawnShell:
{{{
function spawnShell(agent, command, ...)
    return spawn(agent, "/bin/sh", "-c", command, "/bin/sh", ...)
end
}}}

===== terminate(exitcode) =====
Lets Lsyncd terminate with {{{{exitcode}}}}.

==== event =====
Variables of the actions are given by the _event_ field. It has following fields.

|| event.config         || the configuration as called with sync{}.  ||
|| event.inlet          || see layer 1 about inlets                  ||
|| event.etype          || the event type. Can be 'ATTRIB', 'CREATE', 'MODIFY', 'DELETE', 'MOVE' ||
|| event.status         || the status of the event. 'wait' when it is ready to be spawned and 'active' if there is a process running associated with this event ||
|| event.isdir          || true if the event relates to a directory ||
|| event.name           || the filename. directories end with a slash ||
|| event.basename       || the filename. directories do not end with a slash ||
|| event.path           || see ^path of layer 2 ||
|| event.pathname       || see ^pathname of layer 2 ||
|| event.source         || see ^source of layer 2 ||
|| event.sourcePath     || see ^sourcePath of layer 2 ||
|| event.sourcePathname || see ^sourcePathname of layer 2 ||
|| event.target         || see ^target of layer 2 ||
|| event.targetPath     || see ^targetPath of layer 2 ||
|| event.targetPathname || see ^targetPathname of layer 2 ||

onMove actions have two events as parameter, the origin and the destination of the move.

This example will tattle about all moves within the observed dirotery tree.
{{{
tattleMove = {
    onMove = function(oEvent, dEvent)
        log("Normal", "A moved happened from ",oEvent.pathname," to ",dEvent.pathname)
    end,
}}}

A general tip about writing action function is to keep them short and fast. They are running right within Lsyncds one and only main thread. If you have to do any more time consuming calculations _spawn{}_ a child process instead. 

There can only be one child process associated to a event.

Layer 3 is nothing else than Lsyncd automatically write Layer 2 functions for you on initialization. Start lsyncd with {{{-log FWrite}}} on a Layer 3 configuration to see what functions it dynamically writes and loads for you. Thus Layer 3 and 2 can also be be mixed at will.

== Layer 1 Configuration: Inlets == 



= Examples =

= Developer Manual =

When developing it is wise to configure Lsyncd to load the runner from your development directory. So you do not have to rerun make every time you change {{{lsyncd.lua}}}.
{{{
./configure --with-runner=/home/USER/lsyncd2/
}}}

== Roadmap ==

== Why Lua and not ...? =
x