#summary Manual to Lsyncd Version 2.x.
= Contents =
<wiki:toc max_depth="2" />

= Introduction =
Lsyncd version 2.0 is currently at beta1 as a complete recode of Lsyncd 1.x. *This manual is as well in development*.

= What's new in 2.0? =
  * Lsyncd 2.x allows you to specify different actions for different kind of events. Particularly moves can now be implemented to be moved locally at the target instead of hitherto deletion of the origin and retransfer of the destination.

  * Multiple events on one file or directory are still collapsed as in Lsyncd 1.33+. But Lsyncd 2 tracks the kind of event and collapses events logically. E.g. A _Create_ and a _Modify_ will be collapsed in a _Create_; a _Modify_ and a _Delete_ into a _Delete_; a _Create_ and a _Delete_ within the wait time (as it often happens with temporary files) will annihilate each other and result in Lsyncd not bothering the target at all.

  * Multiple targets now each have their own waiting list of events. A slow responding targets server no longer delays other targets.

  * Lsyncd can be configured to run multiple processes at once for one child. It will resolve any conflicts and only run processes in parallel for files and directories that don't interfere with each other.

  * Lsyncd 2.x does no longer halt and wait for a return of child processes it spawned. The kernels inotify queue will thus continously being drained making _Overflows_ less likely.

  * The format of the config file has changed completely. Instead of XML the configuration file has to be valid [http://www.lua.org/ Lua syntax]. 

  * Consequently Lsyncd 2 has no binding to libxml2 anymore, but instead liblua5.1

  * Users can create short scripts right within the config file.

  * Effort has been made while making the most common application of Lsyncd using rsync easy with default settings to keep lsyncd tidy as a general purpose file watching and action tool.

  * Retry on network error is now an integral part of Lsyncd.

  * Has exclude patterns that work.

  * The new setting "statusfile" will instruct Lsyncd to periodically write a report of its status in this file. E.g. amount of directories being watched, events in queue, actions in process etc.

  * A good part of the Lsyncd daemon itself is now coded in Lua. 

= Compiling Lsyncd =

Building Lsyncd is a straight forward standard process for unix packages. Unpack the downloaded tar.gz-file and run:
{{{
./configure
make
sudo make install
}}}

When you grabbed the source directly from subversion run {{{./autogen.sh}}} first.

With this standard configuration the parts of Lsyncd written in Lua (the runner) will be compiled into the binary. This results into a self-sufficient one-file binary. But Lsyncd can be configured to load the runner from an external file with the {{{--with-runner=DIRECTORY}}} option. This is especially useful in Lsyncd development.

= Invoking Lsyncd =

As any unix tool, Lsyncd will print a synopsis of its command line options when called with --help. 
{{{
lsyncd --help
lsyncd -help
}}}
By the way, the two hyphens are redundant for Lsyncd. It has no short one letter options and one hyphen will always result into the same as specifying two.

Also like any unix tools --version or -version will let it print its version number.
{{{
lsyncd -version
}}}

Lsyncd 2.0 is designed to be primarily configured through a config file (see below). The config file can thus be the only command line optin.
{{{
lsyncd CONFIGFILE
}}}

Altough for standard use or quick testing it can be cursorily facilely configured by commandline. This will keep a local src and dst directory in sync using rsync.
{{{
lsyncd -rsync /home/USER/src /home/USER/dst
}}}

The target can here be anything that rsync recognizes.
{{{
lsyncd -rsync /home/USER/src remotehost:dst
}}}

Two (and more) targets are configured by calling -rsync twice (or more).
{{{
lsyncd -rsync /home/USER/src remotehost1:dst -rsync /home/USER/src remotehost2:dst 
}}}

A disadvantage with rsync synchronization is that normally directory and file moves result in a deletion of the move origin and a retransfer of the move destination of the wire. A main improvement of Lsyncd 2.0 is, it now can use ssh commands to move the directories and files locally on the target. To use this use {{{-rsyncssh}}} followed by the local source directory, the remote host and the target directory there. The REMOTEHOST can include a user like {{{me@remotehost.com}}}.
{{{
lsyncd -rsyncssh /home/USER/src REMOTEHOST TARGETDIR
}}}

When testing Lsyncd configurations {{{-nodaemon}}} is a pretty handy flag. With this lsyncd will not detach and become a daemon. All log messages are additionally to the configured logging facilities printed on the console (_stdout_ and _stderr_). 
{{{
lsyncd -nodaemon CONFIGFILE
}}}
Note there is a difference in behaviour. When running with -nodaemon, Lsyncd will not change its working directory to {{{/}}}, as it does when becoming a daemon. Thus relative targets like {{{./target}}} will work with {{{-nodaemon}}}, but must be specified to absolute paths to work in daemon mode. The source directories will also be turned into absolute paths by Lsyncd. The reason targets are not resolved to absolute paths while sources are is because Lsyncd itself does not care about the format of the target specifier which can also be remote hosts, rsyncd modules, etc. It is opaquely handed to rsync. It cares about the observed directories tough.

By default Lsyncd is pretty scarce with logging message. All log messages are sorted in categories. You can turn Lsyncd into a motormouth by specifying {{{-log all}}}.
{{{
lsyncd -log all CONFIGFILE
}}}

This might easily become too much tough. A particularly useful category might be "Exec" which will log the command lines of all processes Lsyncd spawns
{{{
lsyncd -log Exec CONFIGFILE
}}}

Part of lsyncd is written in Lua. By default it is directly compiled into the binary, but can be configured at compiletime and runtime to be loaded from a file as well. To see where the a lsyncd binary will draw its runner from, just call it with {{-runner}}:
{{{
lsyncd -runner
}}}

You can override the default Lsyncd runner with adding a file:
{{{
lsyncd -runner RUNNERFILE
}}}

= The Configuration File =


= Examples =

= Developer Manual =

When developing it is wise to configure Lsyncd to load the runner from your development directory. So you do not have to rerun make every time you change {{{lsyncd.lua}}}.
{{{
./configure --with-runner=/home/USER/lsyncd2/
}}}

== Why Lua and not ...? =
x